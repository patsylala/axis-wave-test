<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>threejs - geometry</title>

    <style>
      body{
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <!-- <audio id="audioSource" src="sounds/loose.mp3"></audio> -->
    <!-- <canvas id="myCanvas"></canvas> -->
    <script src="three.js"></script>
    <script src="noise.js"></script>
    <script src="SVGRenderer.js"></script>
    <script src="SVGLoader.js"></script>
    <script src="Projector.js"></script>
    <script src="Detector.js"></script>
    <!-- <script src="THREE.MeshLine.js"></script> -->
    <script src="OrbitControls.js"></script>

    <script>

      var renderer,
          svgRenderer,
          scene,
          camera,
          controls,
          light, light2,
          ctx,
          audio,
          audioSrc,
          analyser,
          step,
          delta,
          bufferLength,
          frequencyData,
          circles = [],
          cube,cube2,
          sprite2,
          lineLength = 40,
          axis = new THREE.Group(),
          pillar = new THREE.Group(),
          pillarLength = 100,
          lineLength = 40,
          noise = new Noise(10, 12345),
          myCanvas = document.getElementById('myCanvas');

        setup();
        makeScene();
        render();

        function setup() {

        //AUDIO SETUP
        // ctx = new(window.AudioContext || window.webkitAudioContext)();
        // audio = document.getElementById('audioSource');
        // audioSrc = ctx.createMediaElementSource(audio);
        // analyser = ctx.createAnalyser();
        // analyser.fftSize = 2048;
        // audioSrc.connect(analyser);
        // audioSrc.connect(ctx.destination);
        // bufferLength = analyser.frequencyBinCount;
        // frequencyData = new Uint8Array(bufferLength);
        // analyser.getByteTimeDomainData(frequencyData);
        // step = Math.round(frequencyData.length / pillarLength);
        // audio.play();

        //RENDERER
        //renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true});
        renderer = new THREE.SVGRenderer();
        renderer.setClearColor(0x0033D2);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild( renderer.domElement );
        //renderer.setQuality('high');

        //CAMERA
        camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.1, 3000 );
  			camera.position.z = -150;
  			controls = new THREE.OrbitControls( camera, renderer.domElement );
        //controls.enableZoom = false;
        controls.enablePan = false;
        controls.update();
        controls.zoomSpeed = 5.0

        //SCENE
        scene = new THREE.Scene();

        //LIGHTS
        light = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(light);

        light2 = new THREE.PointLight(0xffffff, 0.5);
        scene.add(light2);

      }

      function render() {

        //analyser.getByteTimeDomainData(frequencyData);
        requestAnimationFrame(render);

        // cube.rotation.z = delta;
        // cube2.rotation.z = delta;
        // pillar.rotation.x = delta;
        // pillar.rotation.y = delta;
        // axis.rotation.x = delta;
        // axis.rotation.y = delta;

        // for (let i = 0; i < pillarLength; i++) {
        //   let value = frequencyData[i * step] / 4;
        //   value = value < 1 ? 1 : value;
        //   pillar.children[i].scale.set(
        //   value*.05,
        //   value*.05,
        //   1);
        // }

        if (delta <= 126) {
          delta += 0.01;
        }
        else delta = 0.01;

        for (let i = 0; i < pillar.children.length; i++) {
          pillar.children[i].scale.set(
          -Math.sin((i * .08) + (delta * 5)) + noise.value(i) ,
          -Math.sin((i * .08) + (delta * 5)) + noise.value(i) ,
          1);
        }

        renderer.render(scene, camera);

      }

      function makeScene () {
        let lineGeometry = new THREE.Geometry();
        let pink = new THREE.Color(0xff0082);

        //LINE
        lineGeometry.vertices.push(
          new THREE.Vector3( 0, 0, -lineLength ),
          new THREE.Vector3( 0, 0, lineLength ));
        lineGeometry.computeLineDistances();
        let pink = new THREE.Color(0xff0082);
        var dashedMesh = new THREE.Line(lineGeometry, dashedLineMat);
        let axisLine = new MeshLine();
        axisLine.setGeometry(lineGeometry, function( p ) { return .2; });
        let lineMesh = new THREE.Mesh(axisLine.geometry, new MeshLineMaterial({ color: pink }) );

        //MATERIALS
				let lineMaterial = new THREE.LineDashedMaterial( {
					color: pink,
          linewidth: 1,
          dashSize: 10,
          gapSize: 10
				} );

        let lineBasicMaterial = new THREE.LineBasicMaterial( {
          color: pink,
          linewidth: 2,
        } );

				let line = new THREE.Line( lineGeometry, lineMaterial );

        //CIRCLES
        let circleGeometry = new THREE.Geometry();
        let segment = 60, radius = 10;
        let angle = 2 * Math.PI / segment;
        for (var i = 0; i <= segment; i++) {
            let x = radius * Math.cos(angle * i);
            let y = radius * Math.sin(angle * i);
            circleGeometry.vertices.push(new THREE.Vector3(x, y, 0));
        }

        //PILLAR
        for (let i = 0; i < pillarLength; i++) {
          circles[i] = new THREE.Line(circleGeometry, lineBasicMaterial);
          circles[i].position.z = (i * .3) - ((pillarLength / 2) / 3);
          pillar.add(circles[i]);
        }

        //BOXES
        let box = new THREE.BoxGeometry(  1, 1, 1 );
        let boxMaterial = new THREE.MeshBasicMaterial( {color: 0xff0082} );
        cube = new THREE.Mesh( box, boxMaterial );
        cube2 = new THREE.Mesh( box, boxMaterial );
        cube.position.z = -lineLength;
        cube2.position.z = lineLength;

        //SPRITES
        // let textureLoader = new THREE.TextureLoader;
        // textureLoader.crossOrigin = true;
        //
        // let spriteMaterial = new THREE.SpriteMaterial( { map: textureLoader.load('./axis.png'), color: 0xffffff} );
        // let sprite = new THREE.Sprite(spriteMaterial);
        // sprite.position.set( 0, 0, -lineLength - 10 )
        // sprite.scale.set( 15, 15, 1);
        //
        // let spriteMaterial2 = new THREE.SpriteMaterial( { map: textureLoader.load('./japan-foundation.png'), color: 0xffffff } );
        // let sprite2 = new THREE.Sprite(spriteMaterial2);
        // sprite2.position.set( 0, 0, lineLength + 10 );
        // sprite2.scale.set( 15, 15, 1);

        // let spriteImage = document.createElement( 'img' );
        // spriteImage.src = './axis.png';
        //
        // let spriteTexture = new THREE.Texture( spriteImage );
        // spriteTexture.needsUpdate = true;

        // var svgManager = new THREE.SVGLoader();
        // var url = './axis.svg';
        //
        // svgManager.load(url,
        //                 svg_loading_done_callback,
        //                 function(){console.log("Loading SVG...");},
        //                 function(){console.log("Error loading SVG!");
        //                 });

        //ADD TO SCENE
        axis.add(cube);
        axis.add(cube2);
        // axis.add(sprite);
        // axis.add(sprite2);
        axis.add( line );

        scene.add(axis);
        scene.add(pillar);

        window.addEventListener( 'resize', onWindowResize, false );

      }

      // function svg_loading_done_callback(doc) {
      //   image = new THREE.SVGObject(doc);
      //   image.position.x = 1000;
      //   image.position.y = 1000;
      //   image.position.z = 1000;
      //   scene.add(image);
      // };

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
      }

    </script>
  </body>
</html>
